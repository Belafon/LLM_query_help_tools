const express = require('express');
const cors = require('cors');
const WebSocket = require('ws');
const { spawn } = require('child_process');
const { v4: uuidv4 } = require('uuid');
const http = require('http');
const fs = require('fs');
const path = require('path');
const os = require('os');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

const PORT = process.env.PORT || 3001;



app.use(cors());
app.use(express.json());

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok', message: 'PowerShell Backend Service is running' });
});

// WebSocket connection handler
wss.on('connection', (ws) => {
  console.log('Client connected');
  
  ws.on('message', async (message) => {
    try {
      const data = JSON.parse(message);
      
      switch (data.type) {
        case 'execute':
          await handleScriptExecution(ws, data);
          break;
        default:
          ws.send(JSON.stringify({
            type: 'error',
            message: 'Unknown message type'
          }));
      }
    } catch (error) {
      console.error('Error processing message:', error);
      ws.send(JSON.stringify({
        type: 'error',
        message: 'Error processing request'
      }));
    }
  });

  ws.on('close', () => {
    console.log('Client disconnected');
  });
});

async function handleScriptExecution(ws, data) {
  const sessionId = uuidv4();
  const { script, scriptName } = data;

  try {
    // Send execution start message
    ws.send(JSON.stringify({
      type: 'execution_start',
      sessionId,
      message: `Opening new console window for "${scriptName || 'Unnamed Script'}"`
    }));

    // Create temporary files
    const tempDir = os.tmpdir();
    const scriptFileName = `ps_script_${sessionId}.ps1`;
    const batchFileName = `run_script_${sessionId}.bat`;
    const scriptPath = path.join(tempDir, scriptFileName);
    const batchPath = path.join(tempDir, batchFileName);

    // Create PowerShell script with proper formatting
    const psScript = `# PowerShell Script: ${scriptName || 'Unnamed Script'}
# Generated by PowerShell Manager
$Host.UI.RawUI.WindowTitle = "PowerShell Manager - ${scriptName || 'Unnamed Script'}"

Write-Host "===================================================" -ForegroundColor Cyan
Write-Host "PowerShell Manager - Executing: ${scriptName || 'Unnamed Script'}" -ForegroundColor Cyan
Write-Host "===================================================" -ForegroundColor Cyan
Write-Host ""

try {
    # User script starts here
${script}
    # User script ends here
    
    Write-Host ""
    Write-Host "=== Script execution completed successfully ===" -ForegroundColor Green
} catch {
    Write-Host ""
    Write-Host "=== Error occurred during script execution ===" -ForegroundColor Red
    Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
}

Write-Host ""
Write-Host "Press any key to close this window..." -ForegroundColor Yellow
try {
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
} catch {
    Read-Host "Press Enter to close"
}
`;

    // Create diagnostic batch file
    const batchContent = `@echo off
title PowerShell Manager - ${scriptName || 'Unnamed Script'}
echo ========================================
echo PowerShell Manager Debug Information
echo ========================================
echo Script Name: ${scriptName || 'Unnamed Script'}
echo Script Path: ${scriptPath}
echo Batch Path: ${batchPath}
echo Current Directory: %CD%
echo Temp Directory: %TEMP%
echo.
echo Checking if PowerShell script exists...
if exist "${scriptPath}" (
    echo ✓ PowerShell script file exists
    echo File size: 
    dir "${scriptPath}" | findstr ".ps1"
) else (
    echo ✗ PowerShell script file NOT found!
    echo This is the problem - script file was not created properly
    pause
    exit
)
echo.
echo Starting PowerShell execution...
echo Command: powershell.exe -NoProfile -ExecutionPolicy Bypass -File "${scriptPath}"
echo.
powershell.exe -NoProfile -ExecutionPolicy Bypass -File "${scriptPath}"
echo.
echo PowerShell execution finished with exit code: %ERRORLEVEL%
echo.
pause
`;

    // Write both files
    fs.writeFileSync(scriptPath, psScript, 'utf8');
    fs.writeFileSync(batchPath, batchContent, 'utf8');

    // Log the file paths for debugging
    console.log('Created PowerShell script:', scriptPath);
    console.log('Created batch file:', batchPath);
    console.log('Script content preview:', script.substring(0, 100) + '...');

    // Launch batch file in a new console window with debugging
    const psProcess = spawn('cmd.exe', ['/c', 'start', 'cmd.exe', '/k', batchPath], {
      detached: true,
      stdio: 'ignore'
    });

    // Clean up the temporary files after a delay
    setTimeout(() => {
      try {
        if (fs.existsSync(scriptPath)) {
          fs.unlinkSync(scriptPath);
        }
        if (fs.existsSync(batchPath)) {
          fs.unlinkSync(batchPath);
        }
      } catch (error) {
        console.log('Note: Could not clean up temporary files:', error.message);
      }
    }, 60000); // Increased to 60 seconds for debugging

    psProcess.unref(); // Allow the process to run independently

    // Send completion message immediately
    ws.send(JSON.stringify({
      type: 'execution_complete',
      sessionId,
      message: `Script launched in new console window. The window will close automatically when completed.`
    }));

  } catch (error) {
    console.error('Error executing script:', error);
    ws.send(JSON.stringify({
      type: 'error',
      sessionId,
      message: `Execution error: ${error.message}`
    }));
  }
}



// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Shutting down server...');
  
  // No cleanup needed since scripts run in separate console windows
  
  server.close(() => {
    console.log('Server shut down');
    process.exit(0);
  });
});

server.listen(PORT, () => {
  console.log(`PowerShell Backend Service running on port ${PORT}`);
  console.log(`Health check: http://localhost:${PORT}/health`);
});